<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>杨辉三角的三种求法</title>
      <link href="/2022/11/22/%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/"/>
      <url>/2022/11/22/%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/</url>
      
        <content type="html"><![CDATA[<p>求出杨辉三角中第m行的第n个数（按从左往右的顺序）。</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>输入文件triangle.in，只有一行，有二个整数m和n(m&lt;&#x3D;35)，数间用一个空格隔开</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>输出文件triangle.out，也只有一行，有一个整数，表示杨辉三角中第m行的第n个数。</p><p>样例输入</p><p>Copy</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6 3</span><br></pre></td></tr></table></figure><p>样例输出</p><p>Copy</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure><h2 id="数组循环"><a href="#数组循环" class="headerlink" title="数组循环"></a>数组循环</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int m,n;</span><br><span class="line">    long long a[40][40];</span><br><span class="line">    for(int i=1;i&lt;=m;i++)</span><br><span class="line">        for(int j=1;j&lt;=i;j++)</span><br><span class="line">            if(j==1||j==i)</span><br><span class="line">                a[i][j]=1;</span><br><span class="line">            else</span><br><span class="line">                a[i][j]=a[i-1][j-1]+a[i-1][j];</span><br><span class="line">    cout&lt;&lt;a[m][n]&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们先引入一个求组合数的模型</p><h2 id="模型：快速求组合数"><a href="#模型：快速求组合数" class="headerlink" title="模型：快速求组合数"></a>模型：快速求组合数</h2><p>原理：分子与分母中会存在相同的数，可消。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    long long a,b,s=1;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    for(int i=1,j=a;i&lt;=b;i++,j--) //i为分母，j为分子</span><br><span class="line">        s=s*j/i;</span><br><span class="line">    cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组合数"><a href="#组合数" class="headerlink" title="组合数"></a>组合数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int m,n;</span><br><span class="line">    long long s=1;</span><br><span class="line">    cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line">    for(fenmu=1,fenzi=m-1;fenmu&lt;n;fenmu++,fenzi--)</span><br><span class="line">        s=s*fenzi/fenmu;</span><br><span class="line">    cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>随着层数增加，递归写法会造成时间超限问题，因此需要采取<strong>记忆化搜索</strong>的方式减少次数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">long long a[40][40];</span><br><span class="line">long long triangle(int m,int n)</span><br><span class="line">&#123;</span><br><span class="line">    if(n==1||n==m)</span><br><span class="line">        &#123;   </span><br><span class="line">            a[m][n]=1;//记录已经运算过的数</span><br><span class="line">            return 1;</span><br><span class="line">    if(a[m][n]) return a[m][n];//记忆化搜索</span><br><span class="line">    return a[m][n]=triangle(m-1,n-1)+triangle(m-1,n);//记录已经运算过的数,递归</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int m,n;</span><br><span class="line">    cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line">    cout&lt;&lt;triangle(m,n)&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汉诺塔问题</title>
      <link href="/2022/11/16/%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98/"/>
      <url>/2022/11/16/%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>汉诺塔问题是典型的递归问题，首先需要对递归有初步的认知</p><h2 id="递归函数定义"><a href="#递归函数定义" class="headerlink" title="递归函数定义"></a>递归函数定义</h2><p>1.明确函数的使命</p><p>2.明确原问题和子问题</p><p>3.兼顾原问题和子问题（清楚如何定义递归函数才能同时调用原问题和子问题）</p><h2 id="基础情况处理"><a href="#基础情况处理" class="headerlink" title="基础情况处理"></a>基础情况处理</h2><p>数据规模较小时直接返回答案（终止条件）</p><h2 id="递归调用"><a href="#递归调用" class="headerlink" title="递归调用"></a>递归调用</h2><p>这一步被称为超级操作（将其看成整体，不要去纠结中间是怎么实现的）</p><h2 id="递归到当前层"><a href="#递归到当前层" class="headerlink" title="递归到当前层"></a>递归到当前层</h2><p>称为微操作</p><p>为了更加清楚的了解递归函数，现在将其和数学归纳法类比</p><h2 id="递归和数学归纳法的相似处"><a href="#递归和数学归纳法的相似处" class="headerlink" title="递归和数学归纳法的相似处"></a>递归和数学归纳法的相似处</h2><p>​    归纳奠基—&gt;基础情况处理<br>​    归纳假设—&gt;递归调用<br>​    归纳递推—&gt;递归到当前层</p><h2 id="以汉诺塔问题为例实现递归"><a href="#以汉诺塔问题为例实现递归" class="headerlink" title="以汉诺塔问题为例实现递归"></a>以汉诺塔问题为例实现递归</h2><h3 id="基本情况处理"><a href="#基本情况处理" class="headerlink" title="基本情况处理"></a>基本情况处理</h3><p>一片圆盘时，只需一步。</p><h3 id="递归调用、递推到当前层"><a href="#递归调用、递推到当前层" class="headerlink" title="递归调用、递推到当前层"></a>递归调用、递推到当前层</h3><p>以三片圆盘为例</p><p>1.超级操作（上面两个小圆盘从A-&gt;B）</p><p>2.微操作（最下面一个大圆盘A-&gt;C）</p><p>3.超级操作（上面两个小圆盘从B-&gt;C）</p><p>以此类推，当有n个圆盘时</p><p>1.超级操作（上面n-1个小圆盘从A-&gt;B）</p><p>2.微操作（最下面一个大圆盘A-&gt;C）</p><p>3.超级操作（上面n-1个小圆盘从B-&gt;C）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int Hanoi(int n)</span><br><span class="line">&#123;</span><br><span class="line">    if(n==1)return 1;</span><br><span class="line">    return Hanoi(n-1)+1+Hanoi(n-1);</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    cout&lt;&lt;Hanoi(n)&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>鸣谢：<br>本篇博客学习出处 <a href="https://www.bilibili.com/video/BV1C14y1V77j/?share_source=copy_webvd_source=ba9680a64ad714197865e9a659f8779e">https://www.bilibili.com/video/BV1C14y1V77j/?share_source=copy_webvd_source=ba9680a64ad714197865e9a659f8779e</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于自定义函数</title>
      <link href="/2022/11/15/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0/"/>
      <url>/2022/11/15/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>最近在学自定义函数，这里总结一下几个常用的（可能考试会用到的）</p><h3 id="判断是否为素数"><a href="#判断是否为素数" class="headerlink" title="判断是否为素数"></a>判断是否为素数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bool isPrime(int a)</span><br><span class="line">&#123;</span><br><span class="line">    if(a&lt;2)return 0;</span><br><span class="line">    if(a&lt;4)return 1;</span><br><span class="line">    if(a%2==0)return 0;</span><br><span class="line">    for(int i=3;i*i&lt;=a;i+=2)</span><br><span class="line">        if(a%i==0)return 0;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断是否为回文数（回文字符）即-对称"><a href="#判断是否为回文数（回文字符）即-对称" class="headerlink" title="判断是否为回文数（回文字符）即 对称"></a>判断是否为回文数（回文字符）即 对称</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bool isHWS(int a)</span><br><span class="line">&#123;</span><br><span class="line">    int b[1001],num=0;</span><br><span class="line">    while(a)</span><br><span class="line">    &#123;</span><br><span class="line">        b[num++]=a%10;</span><br><span class="line">        a/=10;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int l=0,r=num-1;l&lt;r;l++,r--)</span><br><span class="line">        if(b[l]!=b[r]) return 0;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int gcd(int q,int p)</span><br><span class="line">&#123;</span><br><span class="line">    while(q%p!=0)</span><br><span class="line">    &#123;</span><br><span class="line">        int t=q%p;</span><br><span class="line">        q=p;</span><br><span class="line">        p=t;</span><br><span class="line">    &#125;</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数运用辗转相除法求最大公约数。</p><p>接下来用递归的方法写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int gcd(int p, int q)</span><br><span class="line">&#123;</span><br><span class="line">    if(p%q==0)return q;</span><br><span class="line">    return gcd(q,p%q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意递归函数必须要有终止条件。</p><p>cpp中也有自带的函数求最大公约数  __gcd(a.b)<br>头文件 algorithm<br>该函数int 型和 long long 型都可以，但是要注意a,b类型需一致，且不能为浮点数。</p><h3 id="将十进制数转化为n进制数（以二进制为例）"><a href="#将十进制数转化为n进制数（以二进制为例）" class="headerlink" title="将十进制数转化为n进制数（以二进制为例）"></a>将十进制数转化为n进制数（以二进制为例）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void ejz(int p)</span><br><span class="line">&#123;</span><br><span class="line">    if(p&lt;2) cout&lt;&lt;p;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        ejz(p/2);</span><br><span class="line">        cout&lt;&lt;p%2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者我们可以将其保存在字符数组中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">string ejz(int a)</span><br><span class="line">&#123;</span><br><span class="line">    string t=&quot;&quot;;</span><br><span class="line">    while(a)</span><br><span class="line">    &#123;</span><br><span class="line">        t=char(a%2+&#x27;0&#x27;)+t;//若没有+&#x27;0&#x27;,则强制转换结果为ACSII码a%2所对应的值，与数字字符不相等</span><br><span class="line">        a/=2;</span><br><span class="line">    &#125;</span><br><span class="line">    return t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求斐波那契数列第n项"><a href="#求斐波那契数列第n项" class="headerlink" title="求斐波那契数列第n项"></a>求斐波那契数列第n项</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int Fibo(int n)</span><br><span class="line">&#123;</span><br><span class="line">    int a=1,b=1;</span><br><span class="line">    if(n&lt;=2) return 1;</span><br><span class="line">    for(int i=3;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int c=a+b;</span><br><span class="line">        a=b;</span><br><span class="line">        b=c;</span><br><span class="line">    &#125;</span><br><span class="line">    return b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们用递归的方法再写一遍</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int Fibo(n)</span><br><span class="line">&#123;</span><br><span class="line">    if(n&lt;=2)return 1;</span><br><span class="line">    return Fibo(n-1)+Fibo(n-2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h3><p>由上面的自定义函数可知，用递归方法写函数可以使代码简化，但是运算量很大，容易造成时间超限问题。因此我们可以采取 记忆化搜索 的方法来优化。</p><p>以 求斐波那契第n项 为例<br>取一个数组ff，记录已取的第n项值的大小，这样就不用反复计算，简化运算。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">long long ff[10001]=&#123;0,1,1&#125;;</span><br><span class="line">long long Fibo(int n)</span><br><span class="line">&#123;</span><br><span class="line">    if(n&lt;=2) return 1;</span><br><span class="line">    if(ff[n]&gt;0) return ff[n];</span><br><span class="line">    ff[n]=Fibo(n-1)+Fibo(n-2);</span><br><span class="line">    return ff[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不下降序列</title>
      <link href="/2022/11/14/%E4%B8%8D%E4%B8%8B%E9%99%8D%E5%BA%8F%E5%88%97/"/>
      <url>/2022/11/14/%E4%B8%8D%E4%B8%8B%E9%99%8D%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="不下降序列"><a href="#不下降序列" class="headerlink" title="不下降序列"></a>不下降序列</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个正整数n与n个正整数序列a1,a2,…,an。(1≤n≤100000,1≤ai≤n)每一次你可以做以下操作：<br>(1)选择一个正整数x<br>(2)将所有等于x的数改为0<br>查找将a序列变为不下降序列的最少操作次数。</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>第一行为正整数T(1≤T≤10000),表示有T组测试数据。<br>每组测试数据包括两行,第一行为整数n(1≤n≤100000);第二行为n个正整数a1,a2,…an(1≤ai≤n)。<br>测试数据保证所有的n之和不超过100000。</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>每组数据输出一行，每行一个整数，表示最少操作次数。</p><p>样例输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">3</span><br><span class="line">3 3 2</span><br><span class="line">4</span><br><span class="line">1 3 1 3</span><br><span class="line">5</span><br><span class="line">4 1 5 3 2</span><br><span class="line">4</span><br><span class="line">2 4 1 2</span><br><span class="line">1</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>样例输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>第一组测试数据，选择x&#x3D;3进行操作，操作后得到序列为[0,0,2].<br>第二组测试数据，第一次选择x&#x3D;1,第二次选择x&#x3D;3,操作后得到序列为[0,0,0,0]</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题目要求须保证整体序列是不严格递增的，因此可以从序列的最后一个数字开始往前找，若遇到比该数字大的数，则将所有的这个数变为0。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std; </span><br><span class="line">int t,n,a[100005],b[100005],ans;//全局变量默认是0 </span><br><span class="line">int main()&#123;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line">while( t -- )</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"> for( int i = 1 ; i &lt;= n ; i ++)cin&gt;&gt;a[ i ];</span><br><span class="line"> int p=n;</span><br><span class="line">  while( a[ p ] &gt;= a[ p - 1 ] ) p--;</span><br><span class="line">  p--;</span><br><span class="line">  for( int i = 1 ; i &lt;= p ; i ++)</span><br><span class="line">  &#123;</span><br><span class="line">   if( b[ a[ i ] ] == 0 )</span><br><span class="line">   &#123;</span><br><span class="line">   for( int j = n ; j &gt;= p ; j -- )</span><br><span class="line">   if( a[ i ] == a[ j ] ) p=j;//前面数x变零，找后面有没有x，有x的话p要改成x这个位置 </span><br><span class="line">   ans++;</span><br><span class="line">   b[ a[ i ] ] = 1;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">   cout&lt;&lt;ans&lt;&lt;&#x27;\n&#x27;;</span><br><span class="line">   memset(b,0,sizeof(b));</span><br><span class="line">   ans=0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HELLO WORLD</title>
      <link href="/2022/11/05/2022-11-5-HELLOWORLD/"/>
      <url>/2022/11/05/2022-11-5-HELLOWORLD/</url>
      
        <content type="html"><![CDATA[<h2 id="“Hello-World-”"><a href="#“Hello-World-”" class="headerlink" title="“Hello, World!”"></a>“Hello, World!”</h2><p>这是我的第一篇博客，记录一下他的诞生。<br>接下来初步的打算是整理一下自己半个学期学的东西，发到博客上。<br>以及 祝事事顺利。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
